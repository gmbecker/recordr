% \VignetteIndexEntry{recordr Extending}
% \VignetteDepends{}
% \VignetteKeywords{reprise}
% \VignettePackage{recordr}
\documentclass[10pt]{article}

\usepackage{times}
\usepackage{hyperref}
\usepackage{Sweave}

\textwidth=6.5in
\textheight=8.5in
\oddsidemargin=-.1in
\evensidemargin=-.1in
\headheight=-.3in

\title{Extending recordr with custom backends}
\author{Gabriel Becker}
\date{\today}

\begin{document}

\maketitle
\tableofcontents
\newpage

The \rpkg{recordr} package supports storing metadata and artifacts in either a JSON file or Solr database. To extend \rpkg{recordr} to support a new storage backend, it is necessary to define a derivative of \rclass{VirtHistoryTracker} and implement methods on six generic functions:
\begin{enumerate}
\item \rfun{prep_for_vtdb}, which prepares a \rclass{PlotFeatureSet} for insertion into the backend data store;
\item \rfun{insert_plot}, which inserts the prepared feature set into the database;
\item \rfun{remove_plot}, which removes a plot from the database;
\item \rfun{vt_write}, which writes the the current state of an in-memory backend to disk;\footnote{This function can often be a no-op if \rfun{insert_plot} performs a permanent write operation}
\item \rfun{vt_lookup}, which looks up a single plot based on its ID or an object representing it; and 
\item \rfun{vt_grep}, which provides whatever search functionality is supported by the backend.
\end{enumerate}

These functions are called internally by the user-facing \rfun{addPlot}, \rfun{rmPlot}, and \rfun{findPlot} functions.

For the remainder of this section, we will walk through the creation of a toy-example backend based on \proglang{R} lists. While this would not suffice in practice because it offers no persistence, it will serve as an illustration of how one would implement a backend more generally --- e.g., for MongoDB \cite{mongodb} or your database of choice.

To implement our backend, we first define the S4 class representing an instance of our \rclass{list} backend, \rclass{ListVTBackend}, which simply inherits from the base \rclass{list} class. We also define a constructor, for convenience.

<<>>=
library(recordr}
setClass("ListVTBackend", contains = "list")
ListVTBackend = function() new("ListVTBackend")
@

We then define our methods which will allow \rpkg{recordr} to interact with our backend. For full customization, we could in principle first write a specific \rfun{prep_for_vtdb} method. When writing custom \rfun{prep_for_vtdb} methods, they must:
\begin{itemize}
\item Generate a unique id for the plot, typically by calling \rfun{uniqueID} on the \rclass{PlotFeatureSet};
\item use \rfun{vt_lookup} to confirm no plot with that id already exists in the datastore; 
\item write any image-files that need to be created in the file system; 
\item transform the plot, metadata, and file paths into the form your \rfun{insert_plot} method will be able to process; and
\item return the transformed data
\end{itemize}

In practice, however, \rpkg{recordr} provides an "ANY" method which will generally suffice for most backends. It returns a \rclass{list} with a generated id and a flattened \rclass{list} of the plot's metadata, along with saving out image files based on the options set on your \rclass{ViztrackrDB}. We will use this method by simply not creating a backend-specific one for our \rclass{ListVTBackend} class.  With \rfun{prep_for_vtdb} addressed, we move on to methods for inserting plots into and removing them from our \rclass{list} data store.

All \rfun{instert_plot} and \rfun{remove_plot} methods must accept five arguments:
\begin{enumerate}
\item doc - the document to be inserted or deleted within the datastore;
\item id - the unique id to associate with the added plot, or the id of the plot to remove;
\item db - the \rclass{ViztrackrDB} object containing our options and backend; 
\item backend - the backend to use (this will be extracted from db, but we dispatch on it so it must be a seperate parameter); and,
\item verbose - a logical indicating whether the backend should emit informational messages (if supported)
\end{enumerate}

The methods themselves must then update the backend object by performing the desired insertion or removal, assign the updated backend back into the database, and return the database. In our toy list-backend case, we can achieve this like so:

<<>>=
setMethod("insert_plot", c(doc = "list", id = "character", db = "ViztrackrDB", backend = "ListVTBackend"),
function(doc, id, db, backend, verbose = TRUE) {
    backend[[id]] = doc
    vt_backend(db) = backend
    invisible(db)
}

setMethod("remove_plot", c(doc = "missing", id = "character", db = "ViztrackrDB", backend = "ListVTBackend"),
function(doc, id, db, backend, verbose = TRUE) {
    backend[[id]] = NULL
    vt_backend(db) = backend
    invisible(db)
}
@

Note we are only defining a \rfun{remove_plot} method for when the doc argument is missing, thus our backend only supports removal by id. The \rpkg{recordr} package uses S4 dispatch to funnel all logic through \rclass{character}-based id methods for \rfun{remove_plot}, so no other methods are required.

Along with our \rfun{insert_plot} and \rfun{remove_plot} methods, we must define a \rfun{vt_write} method which finalizes any changes to the \rpkg{recordr} database our backend uses. The framework requires this in order to allow backends to accumulate changes in memory or immediately write them (within \rfun{insert_plot} and \rfun{remove_plot}, in which case \rfun{vt_write} is a simple no-op).

Because our \rclass{list} backend has no persistent storage behind it, our \rfun{vt_write} method does nothing:

<<>>=
setMethod("vt_write", c("ViztrackrDB", "ListVTBackend").
function(db, backend = vt_backend(db)) db )
@

Next is a \rfun{vt_lookup} method, which takes the \rexpr{object}, \rexpr{db}, \rexpr{backend} and \rexpr{exist} parameters. The \rexpr{object}, put simply, is the query. The \rexpr{db} and \rexpr{backend} parameters represent and behave as they have throughout this discussion. Finally, the \rexpr{exist} parameter specifies whether the lookedup plot entry from the data-store (\rexpr{FALSE} --- the default) or whether a logical value indicating whether such an entry was found (\rexpr{TRUE}) should be returned.


The \rexpr{object} argument can be an object representing a plot, a \rclass{PlotFeatureSet} object, or a \rclass{character} id. As with \rfun{remote_plot}, however, general methods provided by \rpkg{recordr} funnel all dispatch through character-based methods, so we only need to provide a \rclass{character} id-based lookup method when defining a backend. We implement this like so:

<<>>=
setMethod("vt_lookup", c("character", "ViztrackrDB", "ListVTBackend"),
function(object, db, backend, exist = FALSE){
    found = which(object == names(backend))
    if(exist)
        return(length(found) > 0)
    else
        return(backend[[found]])
}
@

Finally, the last method we require to define our backend is \rfun{vt_grep}. This accepts a regular expression (\rexpr{pattern}), the usual \rexpr{db} and \rexpr{backend}, a vector of fields to search (\rexpr{fields}), the form in which to return the results (\rexpr{ret_type} --- id, list, or a backend-specific option), and a \rexpr{verbose} option. Its exact behavior may be backend-specific, but it is intended to find matches to \rexpr{pattern} within the selected fields within the backend's datastore.

In the case of our backend, \rfun{vt_grep} will loop through our list and grep for the supplied pattern. We will write a simplied version which always returns the vector of matching ids:

<<>>=

setMethod("vt_grep", c("character", "ViztrackrDB", "ListVTBackend"),
          function(pattern, db, backend, fields = NULL, ret_type = c("id", "list", "backend"),
                   verbose = TRUE) {
    if(is.null(fields)) {
        fields = TRUE ## grab all of them
    }

    inds = sapply(backend$data, function(x)  any(grepl(pattern, paste(x[fields]))))
    names(backend)[inds]
    })
@

With this, our backend is complete and ready for use. 

<<>>=
be = ListVTBackend()
db = ViztrackrDB(backend = be)
vt_lookup(plt, db)
db = addPlot(plt, db)
vt_lookup(plt, db)
@

In this section, we provided methods for all low-level generics (other than 
\rfun{vt_prep_db}, which is only required in special cases), for the purposes 
of illustrating the extension mechanism. In point of fact, however, \rpkg{recordr} 
provides default methods for \rfun{insert_plot}, \rfun{remove_plot}, and 
\rfun{vt_lookup} which work for any backend whose class has \rfun{[[} and %]]}
\rfun{[[<-} methods defined which allow indexing by character, and where  %]]}
assignment of \rexpr{NULL} into an existing entry is equivalent to removal. 
Thus, only \rfun{vt_write} and \rfun{vt_grep} methods are actually required 
in many cases, including the \rclass{list}-backend case we presented here. 
        
\end{document}
